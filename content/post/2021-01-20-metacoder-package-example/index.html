---
title: Metacoder package Example
author: wxhyihuan
date: '2021-01-20'
slug: metacoder-package-example
categories:
  - Metataxo
  - R
tags:
  - Bioinformatics
  - metacoder
---



<p>æœ€è¿‘åœ¨åšä¸€ä¸ªäººä½“å¾®ç”Ÿç‰©ç»„çš„æ•°æ®ï¼Œé‡Œé¢ä½¿ç”¨åˆ°ä¸€ä¸ª <a href="https://github.com/grunwaldlab/metacoder">metacoder</a> çš„åŒ…ï¼Œå¯ä»¥æç¬‘å¸®å¤„ç†è¿™ä¸€ç±»æ•°æ®çš„é‡æ„å’Œè®¡ç®—ï¼Œè€Œä¸”ç»“åˆå…¶ä»–ä¸€äº›åŒ…ï¼Œå¯¹ç³»ç»ŸåŒ–ç”³è¯‰çš„æ“ä½œå³å¯ä»¥å®ç°éå¸¸å¿«é€Ÿåº¦çš„æŸ¥æ‰¾å’Œæ–¹ä¾¿çš„è®¡ç®—ä¸åŒæ°´å¹³çš„ï¼ˆç›¸å¯¹ï¼‰ä¸°åº¦ã€‚</p>
<p>ç¬¬ä¸€éƒ¨åˆ† work.r æ˜¯ä¸»è¦çš„è°ƒç”¨æ•´ç†æ•°æ®å’Œç»˜å›¾å‡½æ•°çš„æµç¨‹è„šæœ¬ï¼š
ğŸ§”</p>
<pre class="r"><code># Script name: work.r
#åŠ è½½å‡½æ•°è„šæœ¬
source(&quot;~/Functions.R&quot;)
# è¯»å–Excelè¡¨æ ¼ä¸­çš„åŸå§‹æ•°æ®æ–‡ä»¶
excelfile&lt;-&quot;~/PacBiovsMiseq.xlsx&quot;

Pb_exc1 &lt;- read_excel(excelfile, sheet = 1)
Ms_exc1 &lt;- read_excel(excelfile, sheet = 2)

# å¯¹ä¸åŒæ•°æ®çš„ç‰©ç§ä¿¡æ¯å‚è€ƒ NCBI taxonomy DB è¿›è¡Œç»Ÿä¸€
pb_taxoinfo_output &lt;- get_ncbi_taxonamy(taxolist = Pb_exc1$Taxon)
# miseqçš„æ•°æ®æ—¶Silva/GreenGeneçš„å½¢å¼ï¼Œéœ€è¦å…ˆæŒ‰å½¢å¼è§£ææå–ï¼Œç„¶åä»NCBIè·å–ç»“æœ
#miseq_taxopasered &lt;- miseq_taxo_paser(taxo_levels_list = Ms_exc1$Taxo)
miseq_taxopasered &lt;- miseq_taxo_paser2(taxo_levels_list = Ms_exc1$Taxon)
mq_taxoinfo_output &lt;- get_ncbi_taxonamy(taxolist = miseq_taxopasered)
save.image()  #ä¿å­˜é•œåƒæ•°æ®

pb_taxo &lt;- pb_taxoinfo_output[[1]]
mq_taxo &lt;- mq_taxoinfo_output[[1]]

pb_unkown &lt;- pb_taxoinfo_output[[2]]
mq_unkown &lt;- mq_taxoinfo_output[[2]]

## 01 ç»˜åˆ¶æŒ‡å®šæ°´å¹³çš„ç‰©ç§é‰´å®š Venn å›¾
get_venn_diagram(pb_taxo, mq_taxo, complevel = taxo_levels[1:6], taxo_levels = taxo_levels)

## 02 è·å–ä¸åŒæ°´å¹³çš„ç‰©ç§äº¤å·®é›†( Venn )ä¿¡æ¯
taxo_venn_at_diff_level &lt;- get_venn_info(pb_taxo, mq_taxo, complevel = taxo_levels[1:6], taxo_levels = taxo_levels)
</code></pre>
<p align="center">
<img src="https://s3.ax1x.com/2021/01/26/sXiZ5j.png" 
width="40%"  alt="Multi-input and multi-output models" >
</p>
<pre class="r"><code>
## 03 å°†ä¸NCBI taxonomy ç»Ÿä¸€åçš„åˆ†ç±»ä¿¡æ¯ä¸ä¸°åº¦è¡¨æ ¼è¿›è¡Œæ•´åˆå¾—åˆ° OTU_Tableå’Œ Taxo mappingæ•°æ®å¯¹è±¡ï¼Œä»¥åŠæ ¹æ®NCBI taxonomy ä¿¡æ¯å°†
# ä¸¤ç§å¹³å°çš„æ ·æœ¬æ•°æ®åˆå¹¶ï¼ˆæ³¨æ„ä¸æ˜¯å°†ç›¸åŒOPU/OTU/Taxoçš„å€¼ç›¸åŠ ï¼‰ï¼Œä¸»è¦æ˜¯å°†æ ·æœ¬ä¿¡æ¯åˆå¹¶åœ¨ä¸€å¼ è¡¨ï¼Œåˆæˆä¸€ä¸ªåŒ…å«æ‰€æœ‰taxonomyåœ¨ä¸¤ä¸ªå¹³å°ä¸­çš„ä¸°åº¦

pb_otu_table &lt;- as_tibble(Pb_exc1[, c(-1, -2, - ncol(Pb_exc1))], .name_repair = &quot;universal&quot;)
pb_otu_table &lt;- dplyr::bind_cols(pb_taxo, pb_otu_table)
colnames(pb_otu_table)
mq_otu_table &lt;- as_tibble(Ms_exc1[, c(-1, -2)], .name_repair = &quot;universal&quot;)
mq_otu_table &lt;- dplyr::bind_cols(mq_taxo, mq_otu_table)
colnames(mq_otu_table)

#åˆæˆä¸€ä¸ªåŒ…å«æ‰€æœ‰taxonomyåœ¨ä¸¤ä¸ªå¹³å°ä¸­çš„ä¸°åº¦æ•°æ®  *#######
pb_sampleids &lt;- c(colnames(pb_otu_table)[(length(taxo_levels) + 1):ncol(pb_otu_table)])
mq_sampleids &lt;- c(colnames(mq_otu_table)[(length(taxo_levels) + 1):ncol(mq_otu_table)])

# æ•´ç†ä¸€å¼ æ ·æœ¬äº†åˆ†ç»„ä¿¡æ¯è¡¨
samples_colname &lt;- c(&quot;sample_id&quot;, &quot;tech&quot;, &quot;groups&quot;)
samples_info &lt;- matrix(0, nrow = (length(pb_sampleids) + length(mq_sampleids)), ncol = length(samples_colname))
colnames(samples_info) &lt;- samples_colname
samples_info[, 1] &lt;- c(pb_sampleids, mq_sampleids)
samples_info[, 2] &lt;- c(rep(&quot;Pacbio&quot;, length(pb_sampleids)), rep(&quot;Miseq&quot;, length(mq_sampleids)))
samples_info[, 3] &lt;- c(rep(&quot;Pacbio&quot;, length(pb_sampleids)), rep(&quot;Miseq&quot;, length(mq_sampleids)))
tmpmqsampleis &lt;- str_replace(mq_sampleids, &quot;_total&quot;, &quot;&quot;)
samples_info[1:length(pb_sampleids), 3][!samples_info[1:length(pb_sampleids), 1] %in% (intersect(tmpmqsampleis, pb_sampleids))] &lt;- &quot;OnlyPacBio&quot;
samples_info[(length(pb_sampleids) + 1):(length(pb_sampleids) + length(mq_sampleids)), 3][!tmpmqsampleis %in% (intersect(tmpmqsampleis, pb_sampleids))] &lt;- &quot;OnlyMiseq&quot;
samples_info &lt;- as.data.frame(samples_info) ### æ•´ç†å®Œæˆçš„æ ·æœ¬ä¿¡æ¯è¡¨
save.image()

# æ•´ç†readæ·±åº¦æ•°æ®è¡¨
lowestlevel &lt;- &quot;genus&quot;
pb_taxo_lineage &lt;- get_lineage(pb_taxo[, 1:which(taxo_levels == lowestlevel)])
pb_taxo_lineage &lt;- dplyr::bind_cols(Lineage = pb_taxo_lineage, pb_otu_table[,])
#pb_taxo_lineage &lt;- as_tibble(pb_taxo_lineage)

mq_taxo_lineage &lt;- get_lineage(mq_taxo[, 1:which(taxo_levels == lowestlevel)])
mq_taxo_lineage &lt;- dplyr::bind_cols(Lineage = mq_taxo_lineage, mq_otu_table[,])
#mq_taxo_lineage &lt;- as_tibble(mq_taxo_lineage)
merged_taxo_tab &lt;- matrix(0, nrow = (nrow(pb_otu_table) + nrow(mq_otu_table)), ncol = (1 + length(taxo_levels) + (ncol(pb_otu_table) - length(taxo_levels)) + (ncol(mq_otu_table) - (length(taxo_levels)))))
colnames(merged_taxo_tab) &lt;- c(colnames(pb_taxo_lineage[1, 1:8]), colnames(pb_taxo_lineage[1, 9:ncol(pb_taxo_lineage)]), colnames(mq_taxo_lineage[1, 9:ncol(mq_taxo_lineage)]))
merged_taxo_tab[1:nrow(pb_taxo_lineage), 1:8] &lt;- as.matrix(pb_taxo_lineage[, 1:8])
merged_taxo_tab[1:nrow(pb_taxo_lineage), 9:(8 + length(pb_sampleids))] &lt;- as.matrix(pb_taxo_lineage[, 9:(8 + length(pb_sampleids))])

merged_taxo_tab[(nrow(pb_taxo_lineage) + 1):nrow(merged_taxo_tab), 1:8] &lt;- as.matrix(mq_taxo_lineage[, 1:8])
merged_taxo_tab[(nrow(pb_taxo_lineage) + 1):nrow(merged_taxo_tab), (9 + length(pb_sampleids)):(8 + length(pb_sampleids) + length(mq_sampleids))] &lt;- as.matrix(mq_taxo_lineage[, 9:(8 + length(mq_sampleids))])

merged_taxo_info &lt;- merged_taxo_tab[, 1:8]
merged_taxo_tib &lt;- as_tibble(merged_taxo_tab[, 9:ncol(merged_taxo_tab)])
merged_taxo_tib &lt;- merged_taxo_tib %&gt;% mutate_if(is.character, as.numeric)

# åˆå¹¶å®Œæˆçš„åŒ…å«ä¸¤ç»„æ ·æœ¬çš„æ•°æ®taxonomy å’Œ ä¸°åº¦ä¿¡æ¯çš„æ•°æ®
merged_taxo_tib &lt;-  as_tibble(dplyr::bind_cols(as_tibble(merged_taxo_info), merged_taxo_tib))


## 04 ä½¿ç”¨metacoderè¿›è¡Œåˆ†æå’Œç»˜å›¾
merged_taxo_parsed &lt;- parse_tax_data(merged_taxo_tib, class_cols = &quot;Lineage&quot;, class_sep = &quot;;&quot;, named_by_rank = TRUE)
# è®¡ç®—Pacbioæ•°æ®ç»„çš„readæ·±åº¦ä¿¡æ¯,åˆ é™¤low-abundance(è¿™é‡Œæš‚æ—¶è®¾ç½®ä¸º min_count=0 ),
merged_taxo_parsed$data$low_counts &lt;- zero_low_counts(merged_taxo_parsed, data = &quot;tax_data&quot;, min_count = 0, cols = c(10:(9 + length(pb_sampleids))))
merged_taxo_parsed &lt;- filter_obs(merged_taxo_parsed, data = &quot;low_counts&quot;, drop_taxa = FALSE)
merged_taxo_parsed$data$taxon_counts &lt;- calc_taxon_abund(merged_taxo_parsed, data = &quot;low_counts&quot;)
merged_taxo_parsed$data$taxon_counts$total &lt;- rowSums(merged_taxo_parsed$data$taxon_counts[, -1])
set.seed(1) # This makes the plot appear the same each time it is run 
heat_tree(merged_taxo_parsed,
          node_label = taxon_names,
          node_size = total,
          node_color = total,
          edge_size_range = c(0.005, 0.005),
          node_size_axis_label = &quot;OTU Count&quot;,
          node_color_axis_label = &quot;Samples with reads&quot;,
          layout = &quot;davidson-harel&quot;, # The primary layout algorithm
          initial_layout = &quot;reingold-tilford&quot;,
          output_file = &quot;merged_taxo_parsed4Pacbio.pdf&quot;)

# è®¡ç®—Miseqæ•°æ®ç»„çš„readæ·±åº¦ä¿¡æ¯,åˆ é™¤low-abundance(è¿™é‡Œæš‚æ—¶è®¾ç½®ä¸º min_count=5 ),
merged_taxo_parsed$data$low_counts_mq &lt;- zero_low_counts(merged_taxo_parsed, data = &quot;tax_data&quot;, min_count = 5, cols = c((10 + length(pb_sampleids)):(9 + length(pb_sampleids) + length(mq_sampleids))))
merged_taxo_parsed &lt;- filter_obs(merged_taxo_parsed, data = &quot;low_counts_mq&quot;, drop_taxa = FALSE)
merged_taxo_parsed$data$taxon_counts_mq &lt;- calc_taxon_abund(merged_taxo_parsed, data = &quot;low_counts_mq&quot;)
merged_taxo_parsed$data$taxon_counts_mq$total_mq &lt;- rowSums(merged_taxo_parsed$data$taxon_counts_mq[, -1])
set.seed(1) # This makes the plot appear the same each time it is run 
heat_tree(merged_taxo_parsed,
          node_label = taxon_names,
          node_size = total_mq,
          node_color = total_mq,
          edge_size_range = c(0.005, 0.005),
          node_size_axis_label = &quot;OTU Count&quot;,
          node_color_axis_label = &quot;Samples with reads&quot;,
          layout = &quot;davidson-harel&quot;, # The primary layout algorithm
          initial_layout = &quot;reingold-tilford&quot;,
          output_file = &quot;merged_taxo_parsed4MiSeq.pdf&quot;)</code></pre>
<p align="center">
<img src="https://s3.ax1x.com/2021/01/26/sXibJs.png" 
width="50%"  alt="Multi-input and multi-output models" >
<img src="https://s3.ax1x.com/2021/01/26/sXVva8.png" 
width="50%"  alt="Multi-input and multi-output models" >
</p>
<pre class="r"><code>##05 è®¡ç®—å„ä¸ªæ ·å“æ•°æ®çš„ç›¸å¯¹ä¸°åº¦obs_props å’Œ å„ä¸ªç‰©ç§çš„ä¸°åº¦tax_abundï¼Œå„ä¸ªtaxoåœ¨å„ç»„æ ·æœ¬ä¸­å‡ºç°çš„æ ·æœ¬æ•°n_samples
merged_taxo_parsed$data$obs_props &lt;- calc_obs_props(merged_taxo_parsed, &quot;tax_data&quot;)
merged_taxo_parsed$data$tax_abund &lt;- calc_taxon_abund(merged_taxo_parsed, &quot;tax_data&quot;)
merged_taxo_parsed$data$n_samples &lt;- calc_n_samples(merged_taxo_parsed, data = &quot;tax_data&quot;)
# ç”±äº Miseq å’Œpacbioçš„æ ·å“å­˜åœ¨ä¸€äº›å…±åŒï¼Œè¿™é‡Œåªå¯¹åœ¨ä¸¤ç§å¹³å°éƒ½è¿›è¡Œæµ‹åºçš„116ä¸ªæ ·æœ¬è¿›è¡Œåˆ†æ
common_samples_id &lt;- samples_info$sample_id[samples_info$groups %in% c(&quot;Pacbio&quot;, &quot;Miseq&quot;)]
common_samples_groups &lt;- samples_info$groups[samples_info$groups %in% c(&quot;Pacbio&quot;, &quot;Miseq&quot;)]
# è®¡ç®—common_samples_idæ ·æœ¬çš„taxo rareferaction æ•°æ®
merged_taxo_parsed$data$comsamp_abund_rarefied &lt;- rarefy_obs(merged_taxo_parsed, &quot;tax_data&quot;, cols = common_samples_id)
merged_taxo_parsed$data$comsamp_tax_abund_rarefied &lt;- calc_taxon_abund(merged_taxo_parsed, &quot;comsamp_abund_rarefied&quot;, cols = common_samples_id)
# è®¡ç®—common_samples_idæ ·æœ¬çš„taxoåœ¨å„ç»„æ ·æœ¬ä¸­å‡ºç°çš„æ ·æœ¬æ•°
merged_taxo_parsed$data$comsamp_tax_abund &lt;- calc_taxon_abund(merged_taxo_parsed, &quot;tax_data&quot;, cols = common_samples_id)
merged_taxo_parsed$data$comsamp_tax_props &lt;- calc_taxon_abund(merged_taxo_parsed, &quot;obs_props&quot;, cols = common_samples_id)
merged_taxo_parsed$data$comsamp_tax_occ &lt;- calc_n_samples(merged_taxo_parsed, &quot;comsamp_tax_abund&quot;, groups = common_samples_groups, cols = common_samples_id)
merged_taxo_parsed$data$comsamp_tax_props_groupmeans &lt;- calc_group_stat(merged_taxo_parsed, &quot;comsamp_tax_props&quot;, mean, groups = common_samples_groups, cols = common_samples_id)
merged_taxo_parsed$data$comsamp_tax_props_groupsd &lt;- calc_group_stat(merged_taxo_parsed, &quot;comsamp_tax_props&quot;, sd, groups = common_samples_groups, cols = common_samples_id)

compafun &lt;- function(abund_1, abund_2) {
  log_ratio &lt;- log2(median(abund_1) / median(abund_2))
  if (is.nan(log_ratio)) {
    log_ratio &lt;- 0
  }
  list(log2_median_ratio = log_ratio,
    median_diff = median(abund_1) - median(abund_2),
    mean_diff = mean(abund_1) - mean(abund_2),
    mean_diff_ration = mean(abund_1) / mean(abund_2),
    wilcox_p_value = wilcox.test(abund_1, abund_2)$p.value,
    ttest_p_value = t.test(abund_1, abund_2)$p.value)
}

merged_taxo_parsed$data$diff_table &lt;- compare_groups(merged_taxo_parsed,
                                      dataset = &quot;comsamp_tax_abund&quot;,
                                      cols = common_samples_id, # What columns of sample data to use
                                      groups = common_samples_groups) # What category each sample is assigned to
merged_taxo_parsed$data$diff_table_taxprops &lt;- compare_groups(merged_taxo_parsed,
                                      dataset = &quot;comsamp_tax_props&quot;,
                                      cols = common_samples_id, # What columns of sample data to use
                                      groups = common_samples_groups,
                                      func = compafun)
merged_taxo_parsed$data$diff_table_taxprops$fdr_wilcox_p_value &lt;- p.adjust(merged_taxo_parsed$data$diff_table_taxprops$wilcox_p_value, method = &quot;fdr&quot;)
merged_taxo_parsed$data$diff_table_taxprops$bfn_ttest_p_value &lt;- p.adjust(merged_taxo_parsed$data$diff_table_taxprops$ttest_p_value, method = &quot;bonferroni&quot;)

set.seed(1)
heat_tree(merged_taxo_parsed,
          node_label = taxon_names,
          node_size = 0.5, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
          node_color = log2_median_ratio, # A column from `obj$data$diff_table`
          node_color_interval = c(-4, 4), # The range of `log2_median_ratio` to display
          node_color_range = diverging_palette(), # The color palette used
          node_size_axis_label = &quot;OTU count&quot;,
          node_color_axis_label = &quot;Log 2 ratio of median proportions&quot;,
          layout = &quot;davidson-harel&quot;, # The primary layout algorithm
          initial_layout = &quot;reingold-tilford&quot;,
          output_file = &quot;differential_heat_tree_taxabund.pdf&quot;) # The layout algorithm that initializes node locations
set.seed(1)
heat_tree(merged_taxo_parsed,
          node_label = taxon_names,
          node_size = 0.5, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
          node_color = merged_taxo_parsed$data$diff_table_taxprops$log2_median_ratio,
          node_color_interval = c(-4, 4), # The range of `log2_median_ratio` to display
          node_color_range = diverging_palette(), # The color palette used
          node_color_axis_label = &quot;Log 2 ratio of median proportions&quot;,
          layout = &quot;davidson-harel&quot;, # The primary layout algorithm
          initial_layout = &quot;reingold-tilford&quot;,
          output_file = &quot;differential_heat_tree_taxprops.pdf&quot;)

## ç»˜åˆ¶116ä¸ªåœ¨åŒå¹³å°æµ‹åºçš„ *æ‰€æœ‰* taxoåœ¨ä¸åŒåˆ†ç±»æ°´å¹³ï¼ˆç”¨é¢œè‰²åŒºåˆ†ï¼‰çš„ç›¸å…³ç³»æ•°
colorssets &lt;- unlist(merged_taxo_parsed$taxon_ranks())
colorssets &lt;- as.character(colorssets)
colsrow &lt;- c(&quot;#c12e34&quot;, &quot;#e6b600&quot;, &quot;#0098d9&quot;, &quot;#2b821d&quot;, &quot;#005eaa&quot;, &quot;#339ca8&quot;, &quot;#cda819&quot;, &quot;#32a487&quot;)
tmpsets &lt;- unique(colorssets)
for (i in 1:length(tmpsets)) {
  colorssets[which(colorssets == tmpsets[i])] &lt;- colsrow[i]
}

basestpe = length(common_samples_id) / 2
figs_list &lt;- list()
for (i in 2:(basestpe + 1)) {
  pb_tmpX &lt;- merged_taxo_parsed$data$comsamp_tax_props[, i]
  mq_tmpy &lt;- merged_taxo_parsed$data$comsamp_tax_props[, i + basestpe]
  main &lt;- paste(names(pb_tmpX),&quot; in PacBio &amp; Miseq&quot;, sep = &quot;&quot;)
  get_ggpoint(pb_tmpX, mq_tmpy, col = colorssets, main = main, Single = TRUE, mergeif = FALSE)
  tm_figs &lt;- get_ggpoint(pb_tmpX, mq_tmpy, col = colorssets, main = main, Single = FALSE, mergeif = TRUE)
  figs_list[[length(figs_list) + 1]] &lt;- tm_figs
  #print(main)
}
library(&quot;cowplot&quot;)
library(&quot;Cairo&quot;)
CairoPDF(file = &quot;Merged.pdf&quot;, width = 30, height = 30)
par(mfcol = c(11, 11))
plot_grid(plotlist = figs_list)
dev.off()
</code></pre>
<p align="center">
<img src="https://s3.ax1x.com/2021/01/26/sXkAhj.png" 
width="40%"  alt="Multi-input and multi-output models" >
<img src="https://s3.ax1x.com/2021/01/26/sXkkNQ.png" 
width="40%"  alt="Multi-input and multi-output models" >
</p>
<pre class="r"><code>##08 ç»˜åˆ¶116æ ·æœ¬åœ¨KPCOFGæ°´å¹³çš„correlaton constants æŸ±å½¢å›¾
samples116_CorConstants_difflevels &lt;- list()
for (ele in names(colors_diff_levels)) {
  temp_comsamp_tax_props &lt;- merged_taxo_parsed$data$comsamp_tax_props[which(colorssets == ele),]
  basestpe = length(common_samples_id) / 2
  tmp_figs_list &lt;- list()
  for (i in 2:(basestpe + 1)) {
    pb_tmpX &lt;- as.numeric(unlist(temp_comsamp_tax_props[, i]))
    mq_tmpy &lt;- as.numeric(unlist(temp_comsamp_tax_props[, i + basestpe]))
    lm_val &lt;- lm(mq_tmpy ~ pb_tmpX)
    corConstant &lt;- lm_val$coefficients[2]
    tmp_figs_list[[length(tmp_figs_list) + 1]] &lt;- corConstant
    #print(main)
  }
  samples116_CorConstants_difflevels[[length(samples116_CorConstants_difflevels) + 1]] &lt;- tmp_figs_list
}
samples116_CorConstants_difflevels_df &lt;- as.data.frame(matrix(unlist(samples116_CorConstants_difflevels), nrow = length(unlist(samples116_CorConstants_difflevels[1]))))
colnames(samples116_CorConstants_difflevels_df) &lt;- taxo_levels[1:ncol(samples116_CorConstants_difflevels_df)]
tmpcolors &lt;- samples116_CorConstants_difflevels_df
colnames(tmpcolors) &lt;- colsrow[1:ncol(tmpcolors)]
tmpcolors &lt;- stack(tmpcolors)
samples116_CorConstants_difflevels_df &lt;- stack(samples116_CorConstants_difflevels_df)
colnames(samples116_CorConstants_difflevels_df) &lt;- c(&quot;Value&quot;, &quot;Levels&quot;)
colnames(tmpcolors) &lt;- c(&quot;Value&quot;, &quot;Colors&quot;)

df.summary &lt;- samples116_CorConstants_difflevels_df %&gt;%
  group_by(Levels) %&gt;%
  summarise(
    sd = sd(Value, na.rm = TRUE),
    Value = mean(Value),
  )

outilfename &lt;- paste(&quot;All Correlation Constants at six levles&quot;, &quot;.pdf&quot;, sep = &quot;&quot;)
CairoPDF(file = outilfename, width = 10, height = 10)
boxplots &lt;- ggplot(samples116_CorConstants_difflevels_df, aes(Levels, Value)) +
  geom_jitter(position = position_jitter(0.2), color = tmpcolors$Colors) +
  geom_line(aes(group = 1), data = df.summary, linetype = 2) +
  geom_errorbar(aes(ymin = Value - sd, ymax = Value + sd), data = df.summary, width = 0.2) +
  geom_point(data = df.summary, size = 4, shape = 8, fill = &quot;red&quot;) +
  theme(plot.title = element_text(size = 10), text = element_text(size = 16, family = &quot;TT Times New Roman&quot;), axis.text = element_text(size = 18), axis.title = element_text(size = 18, face = &quot;bold&quot;))
par(mfcol = c(1, 1))
print(boxplots)
dev.off()
save.image()
</code></pre>
<p align="center">
<img src="https://s3.ax1x.com/2021/01/26/sXAFr6.png" 
width="40%"  alt="Multi-input and multi-output models" >
<img src="https://s3.ax1x.com/2021/01/26/sXAiKx.png" 
width="40%"  alt="Multi-input and multi-output models" >
</p>
<p>ç¬¬äºŒéƒ¨åˆ† Functions.r æ˜¯ä¸»è¦çš„æ”¶é›†ç‰©ç§ä¿¡æ¯å’Œç»˜å›¾çš„å‡½æ•°çš„è„šæœ¬ï¼š</p>
<pre class="r"><code>library(&#39;readxl&#39;)
library(&#39;taxonomizr&#39;)
library(&#39;tidyverse&#39;)
library(&#39;metacoder&#39;)
library(&quot;cowplot&quot;)
library(&#39;ggplot2&#39;)
library(&#39;ggforce&#39;)
library(&quot;Cairo&quot;)

# è¯»å–excelæ•°æ®
library(&#39;readxl&#39;)
# æå–NCBI taxonomy ä¿¡æ¯
library(&#39;taxonomizr&#39;)
# æ•´ç†æ•°æ®
library(&#39;tidyverse&#39;)

## è®¾ç½®é™æ€å˜é‡
taxo_levels &lt;- c(&quot;superkingdom&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;)
taxo_levels_short &lt;- c(&quot;k__&quot;, &quot;p__&quot;, &quot;c__&quot;, &quot;o__&quot;, &quot;f__&quot;, &quot;g__&quot;, &quot;s__&quot;)
# taxonomizr åŒ…ä½¿ç”¨çš„ NCBI taxonomy æ•°æ®åº“(sqlæ ¼å¼)
nameNodesqlfile &lt;- &quot;~/nameNode.sqlite&quot;



## ç”¨æ¥è·å–NCBI taxonomyä¿¡æ¯
get_ncbi_taxonamy &lt;- function(taxolist, nameNodesqlfile = &quot;~/nameNode.sqlite&quot;) {
  len &lt;- length(taxo_levels)
  taxoinfo_array &lt;- data.frame(t(1:len))
  colnames(taxoinfo_array) &lt;- taxo_levels
  taxoinfo_array &lt;- taxoinfo_array[-1,]
  tatol_taxo_NO &lt;- 0
  ncbi_taxoedNO &lt;- 0
  unkown_taxo &lt;- c()
  for (ele in taxolist) {

    tatol_taxo_NO &lt;- tatol_taxo_NO + 1
    # å°† ä¼ å…¥ çš„æ•°æ®æŒ‰ç…§ä¸€èˆ¬çš„è®°å½•ä¹ æƒ¯è¿›è¡Œç‹ ä¸ªï¼Œè¿™é‡Œåªæ˜¯ç”¨å±genusæˆ–ä»¥ä¸Šçš„ç‰©ç§ä¿¡æ¯æŸ¥è¯¢
    # å› ä¸ºæœ‰å¾ˆå¤šç–‘ä¼¼æ–°ç§ï¼Œå¹¶ä¸”å­¦åå¤ªé•¿ï¼Œå­˜åœ¨æ›´å¤§å¯èƒ½çš„è®°å½•é”™è¯¯å¯¼è‡´æ— æ³•æŸ¥è¯¢ä¿¡æ¯
    slfe_or_above_taxo &lt;- str_split(ele, &quot; |_&quot;, simplify = T) # æŒ‰ç…§ ç©ºæ ¼ å’Œ/æˆ– ä¸‹åˆ’çº¿åˆ†å‰²
    taxoids &lt;- getId(slfe_or_above_taxo[1], sqlFile = nameNodesqlfile, onlyScientific = FALSE)

    if (taxoids != &quot;&quot;) {
      taxoids &lt;- str_split(taxoids, &quot;,&quot;, simplify = T)
      tempinfo &lt;- getTaxonomy(taxoids[1], sqlFile = nameNodesqlfile, desiredTaxa = taxo_levels)
      #cat(taxoids[1], &quot;\t&quot;, ele, &quot;\t&quot;, tempinfo, &quot;\n&quot;)

      #åˆ¤æ–­æ˜¯å¦ä¸º ç§æ°´å¹³ species çš„æƒ…å†µï¼š è¦æ±‚genus éNAï¼Œå¹¶ä¸”slfe_or_above_taxoçš„é•¿åº¦ä¸å°äº2
      genus_level &lt;- which(taxo_levels == &quot;genus&quot;)
      if (as.logical((!is.na(tempinfo[genus_level])) &amp;&amp; (ncol(slfe_or_above_taxo) &gt;= 2))) {
        #print (ele)
        tempinfo[len] &lt;- ele
      }
      #print (tempinfo)
      if (!is.na(tempinfo[1])) {
        taxoinfo_array[nrow(taxoinfo_array) + 1, 1:ncol(taxoinfo_array)] &lt;- tempinfo
        #cat(taxoids[1], &quot;\t&quot;, ele, &quot;\t&quot;, tempinfo, &quot;\n&quot;)
      } else {
        # è®°å½• è¿™ä¸€æ­¥åœ¨NCBIç§æ‰¾ä¸åˆ° taxonomy ä¿¡æ¯çš„æ¡ç›®
        taxoinfo_array[nrow(taxoinfo_array) + 1, 1:ncol(taxoinfo_array)] &lt;- rep(NA, 7)
        unkown_taxo &lt;- c(unkown_taxo, ele)
      }
    } else {
      # è®°å½• è¿™ä¸€æ­¥åœ¨NCBIç§æ‰¾ä¸åˆ° taxonomy ä¿¡æ¯çš„æ¡ç›®
      taxoinfo_array[nrow(taxoinfo_array) + 1, 1:ncol(taxoinfo_array)] &lt;- rep(NA, 7)
      unkown_taxo &lt;- c(unkown_taxo, ele)
    }
  }
  return(list(taxoinfo_array, unkown_taxo))
}

# å¦‚æœä¸ç”¨NCBIæ•°æ®ç»Ÿä¸€ï¼Œè€Œç›´æ¥ä½¿ç”¨è¡¨æ ¼ä¸­çš„Silva taxonomy ä¿¡æ¯ï¼Œè¿™å¯¹å…¶è¿›è¡Œè§£æ„
get_silva_taxonamy &lt;- function(taxo_levels_list) {
  len &lt;- length(taxo_levels)
  slv_taxoinfo_array &lt;- data.frame(t(1:len))
  colnames(slv_taxoinfo_array) &lt;- taxo_levels
  tatol_taxo_NO &lt;- 0
  ncbi_taxoedNO &lt;- 0
  for (ele in taxo_levels_list) {
    tatol_taxo_NO &lt;- tatol_taxo_NO + 1
    ele &lt;- str_replace_all(ele, &quot; +&quot;, &quot;&quot;) #æ›¿æ¢ç©ºæ ¼
    tmp_pase &lt;- parse_tax_data(ele, class_sep = &quot;;&quot;)
    slv_taxoinfo_array[tatol_taxo_NO, 1:length(tmp_pase$taxonomy_table())] &lt;- tmp_pase$taxonomy_table()
  }
  return(slv_taxoinfo_array)
}

miseq_taxo_paser &lt;- function(taxo_levels_list, redundancy.method = &quot;Best&quot;) {
  output_taxo_levels_list &lt;- c()
  if (redundancy.method == &quot;Best&quot;) {
    for (ele in taxo_levels_list) {
      tmp_taxos &lt;- str_split(ele, &quot;;&quot;, simplify = TRUE)
      if (length(grep(&quot;OPU_?[\\d]&quot;, tmp_taxos[1], ignore.case = TRUE, perl = TRUE)) == 0) {
        output_taxo_levels_list &lt;- c(output_taxo_levels_list, tmp_taxos[1])
        #cat(tmp_taxos[1], &quot;\n&quot;)
      } else {
        output_taxo_levels_list &lt;- c(output_taxo_levels_list, ele)
      }
    }
  } else if ((redundancy.method == &quot;LCA&quot;)) {
    print(&quot;Unuseing function~~&quot;)
  }
  return(output_taxo_levels_list)
}


## ç›´æ¥è§£æGreenGeneæ ¼å¼çš„ä¿¡æ¯
miseq_taxo_paser2 &lt;- function(taxo_levels_list) {
  library(&quot;taxa&quot;)
  output_taxo_levels_list &lt;- c()
  for (ele in taxo_levels_list) {
    tmp_taxos &lt;- parse_tax_data(ele, class_sep = &quot;;&quot;, class_regex = &quot;[kpcofgs]__(.*)&quot;)
    taxonames &lt;- as.character(unlist(as.data.frame(tmp_taxos$taxon_names())))
    taxonames&lt;-str_replace_all(taxonames,&quot;_+&quot;,&quot; &quot;)
    taxoids &lt;- getId(taxonames, sqlFile = nameNodesqlfile, onlyScientific = FALSE)
    last_taxon &lt;- taxonames[which(taxoids != &quot;&quot;)][length(which(taxoids != &quot;&quot;))]
    output_taxo_levels_list &lt;- c(output_taxo_levels_list, last_taxon)
  }
  return(output_taxo_levels_list)
}


### ç»˜åˆ¶æŒ‡å®šæ°´å¹³çš„ç‰©ç§é‰´å®š Venn å›¾ å‡½æ•°
get_venn_diagram &lt;- function(pb_taxo, mq_taxo, complevel = taxo_levels[6:7], taxo_levels = taxo_levels, alpha = 0.75) {
  library(&quot;VennDiagram&quot;)
  for (ele in complevel) {
    i &lt;- which(taxo_levels == ele)
    pb_tmp_level_taxos &lt;- unique(na.exclude(pb_taxo[, i]))
    mq_tmp_level_taxos &lt;- unique(na.exclude(mq_taxo[, i]))
    tmp_list &lt;- list(
      Pacbio = pb_tmp_level_taxos,
      Miseq = mq_tmp_level_taxos)
    maintitle &lt;- paste(&quot;Venn figure at &quot;, ele, &quot; level  &quot;, sep = &quot;&quot;)
    figname &lt;- paste(ele, &quot;_level_venn_scaled&quot;, &quot;.tiff&quot;, sep = &quot;&quot;)
    venn.plot &lt;- venn.diagram(tmp_list,
      category = c(&quot;PacBio&quot;, &quot;Miseq&quot;),
      col = c(&quot;#3E638B&quot;),
      fill = c(&quot;#ADDB7D&quot;, &quot;#8ECCF2&quot;),
      euler.d = TRUE,
      filename = figname,
      cex = 1.2,
      cat.pos = 0,
      imagetype = &quot;tiff&quot;,
      alpha = alpha,
      lwd = 2, hyper.test = TRUE,
      compression = &#39;lzw&#39;, fontface = &quot;italic&quot;,
      cat.cex = 1.2,
      cat.fontface = &quot;bold&quot;,
      print.mode = c(&quot;raw&quot;, &quot;percent&quot;),
      sigdigs = 4,
      main = maintitle,
      main.cex = 2,
      main.fontface = &quot;bold&quot;,
  )
  }
}

get_venn_info &lt;- function(pb_taxo, mq_taxo, complevel = taxo_levels[1:6], taxo_levels = taxo_levels) {
  library(gplots)
  out_list &lt;- list()
  for (ele in complevel) {
    i &lt;- which(taxo_levels == ele)
    pb_tmp_level_taxos &lt;- unique(na.exclude(pb_taxo[, i]))
    mq_tmp_level_taxos &lt;- unique(na.exclude(mq_taxo[, i]))
    tmp_list &lt;- list(
      Pacbio = pb_tmp_level_taxos,
      Miseq = mq_tmp_level_taxos)
    venn_tab &lt;- venn(tmp_list, show.plot = FALSE)
    out_list &lt;- c(out_list, list(i = attr(venn_tab, &quot;intersections&quot;)))
  }
  names(out_list) &lt;- complevel
  return(out_list)
}

get_lineage &lt;- function(pbmq_taxo) {
  out_lineage_tab &lt;- c()
  for (i in 1:nrow(pbmq_taxo)) {
    str_tmp &lt;- &quot;&quot;
    for (j in 1:length(pbmq_taxo[i, ])) {
      ele &lt;- pbmq_taxo[i, j]
      if (!is.na(ele)) {
        str_tmp = paste(str_tmp, paste(ele, sep = &quot;&quot;), sep = &quot;&quot;)
        str_tmp &lt;- paste(str_tmp, &quot;;&quot;, sep = &quot;&quot;)
      }
    }
    str_tmp &lt;- str_replace(str_tmp, &quot;;$&quot;, &quot;&quot;)
    out_lineage_tab &lt;- c(out_lineage_tab, str_tmp)
  }
  return(out_lineage_tab)
}


get_ggplotlines &lt;- function(x, y, main = &quot;Test_figs&quot;) {
  library(&#39;ggplot2&#39;)
  theme_set(theme_minimal())
  x &lt;- as.numeric(unlist(x))
  y &lt;- as.numeric(unlist(y))
  figs &lt;- ggplot(x = x, y = y) +
    geom_line(aes(x = 1:length(x), y = x), color = &quot;darkred&quot;) +
    geom_line(aes(x = 1:length(y), y = y), color = &quot;steelblue&quot;, linetype = &quot;twodash&quot;)
  ggsave(filename = paste(main, &quot;.pdf&quot;, sep = &quot;&quot;), device = &quot;pdf&quot;, plot = figs)
}

get_ggpoint &lt;- function(x, y, col, main = &quot;Test_figs&quot;, mergeif = TRUE, Single = TRUE) {
  library(&#39;ggplot2&#39;)
  library(&#39;ggforce&#39;)
  x &lt;- as.numeric(unlist(x))
  y &lt;- as.numeric(unlist(y))
  cor_val &lt;- cor(x, y)
  lm_val &lt;- lm(y ~ x)
  Constant &lt;- lm_val$coefficients[2]
  data &lt;- as.data.frame(cbind(x, y))
  if (Single) {
    figs &lt;- ggplot(data, aes(x = x, y = y)) + ggtitle(main) +
    xlab(&quot;PacBio|Taxonomy abundance&quot;) + ylab(&quot;Miseq|Taxonomy abundance&quot;) +
    geom_point(shape = 21, size = 1.5, colour = &quot;black&quot;, fill = col, alpha = 0.8) +
    geom_smooth(method = &quot;lm&quot;, se = TRUE, colour = &quot;blue&quot;, fill = &quot;blue&quot;, alpha = 0.3, size = 1.1) +
    geom_vline(aes(xintercept = mean(x)), linetype = 2) +
    geom_hline(aes(yintercept = mean(y)), linetype = 2) +
    geom_point(aes(mean(x), mean(y)), shape = 16, size = 0.5, colour = &quot;green&quot;, alpha = 0.5) +
    facet_zoom(xlim = c(0, 0.05), ylim = c(0, 0.05), split = TRUE) +
    annotate(&quot;text&quot;, x = 0.325, y = 0.85, label = paste(&quot;r=&quot;, round(cor_val, 2), &quot;\nConstant=&quot;, round(Constant, 3), sep = &quot;&quot;),
    colour = &quot;red&quot;, size = 2, fontface = &quot;bold&quot;) +
    theme_bw()
    ggsave(filename = paste(main, &quot;.pdf&quot;, sep = &quot;&quot;), device = &quot;pdf&quot;, plot = figs)
  }
  if (mergeif) {
    figs &lt;- ggplot(data, aes(x = x, y = y)) + ggtitle(main) +
    xlab(&quot;PacBio|Taxonomy abundance&quot;) + ylab(&quot;Miseq|Taxonomy abundance&quot;) +
    geom_point(shape = 21, size = 1, colour = &quot;black&quot;, fill = col, alpha = 0.8) +
    geom_smooth(method = &quot;lm&quot;, se = TRUE, colour = &quot;blue&quot;, fill = &quot;blue&quot;, alpha = 0.3, size = 0.2) +
    geom_vline(aes(xintercept = mean(x)), linetype = 2) +
    geom_hline(aes(yintercept = mean(y)), linetype = 2) +
    geom_point(aes(mean(x), mean(y)), shape = 16, size = 0.3, colour = &quot;green&quot;, alpha = 0.5) +
    annotate(&quot;text&quot;, x = 0.325, y = 0.85, label = paste(&quot;r=&quot;, round(cor_val, 2), &quot;\nConstant=&quot;, round(Constant, 3), sep = &quot;&quot;),
    colour = &quot;red&quot;, size = 1, fontface = &quot;bold&quot;) +
    xlim(-0.01, 1) + ylim(-0.01, 1) +
    theme(plot.title = element_text(size = 5))
    theme_bw() +
    return(figs)
  }
}</code></pre>
